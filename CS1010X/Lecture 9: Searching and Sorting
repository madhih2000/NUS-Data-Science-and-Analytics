Question 1

What will the following statement evaluate to?

[1, [2, 1], 1, [3, [1, 3]], [4, [1], 5], [1], 1, [[1]]].count(1)

Ans:

3

Question 2: List Popping

The lectures have introduced you to the idea of (im)mutability. Tuples are immutable data structures. Once created, cannot be modified. If we want to remove an item from a tuple, a new tuple will have to be created.

Define a function pop_at_index that accepts a tuple and an index as a parameter. If the index is valid, the function should return a tuple that contains the exact same elements except for the element at that index, else return the original tuple.

Hint: Note the possibility of negative indices!

Ans:


def pop_at_index(seq, index):
    if index >= len(seq) or index < -len(seq):
        return seq
    else:
        seq = list(seq)
        seq_pop = seq.pop(index)
        seq_tup = tuple(seq)
        return seq_tup
        
Question 3

What is the output of the code below?

list1 = [1] * 4
list2 = [5, 5, 5]
while not 0:
    list1[0] += 1
    if list1[0] == 5: 
         break
         list1[1] += 2
    list1[2] += 3

print(list1 < list2)
print(list2 == (5, 5, 5))

Ans:

True False

Question 4

Write a function remove_extras(lst) that takes in a list and returns a new list with all repeated occurrences of any element removed. For example, remove_extras([5, 2, 1, 2, 3]) returns the list [5, 2, 1, 3].

Ans:


def remove_extras(lst):
    newlist = []
    for number in lst:
       if number not in newlist:
           newlist.append(number)
    return newlist
   
   
Question 5

Now, reimplement remove_extras(lst) such that it takes in a list and returns the same list with all repeated occurances removed. The order of the elements in the returned list does not matter. For this question, you may use sort or any other python list functions to make your life easier.

Note: that you should never modify a list while iterating through the it (see / recall Tutorial 5).
Note: check_elements is a function that checks if two lists contain exactly the same elements. It is used to compare the result generated by your implementation with the expected answer because the order of elements in the two lists may defer. You do not need to implement the function, it has already been implemented.

Ans:


def remove_extras(lst):
    lst.sort()
    i = len(lst) - 1
    while i > 0:  
        if lst[i] == lst[i - 1]:
            lst.pop(i)
        i -= 1
    return lst
# Do not remove the following code
lst1 = [1, 5, 1, 1, 3]
lst2 = [2, 2, 2, 1, 5, 4, 4]
result1 = remove_extras(lst1)
result2 = remove_extras(lst2)


Question 6

What is the output of the following?

alist = [4, 2, 8, 6, 5]
alist[2] = True
alist[2:2] = [False]
print(alist)

Ans:

[4, 2, False, True, 6, 5]

Question 7

Define a function count_occurrences that accepts:
lst, a list containing integers that can contain multiple levels of nested lists
num, an integer
and counts the number of times num appears in lst.

Ans:

def count_occurrences(lst, num):
    if lst == []:
        return 0
    if lst[0] == num:
        return 1 + count_occurrences(lst[1:], num)
    elif type(lst[0]) == list:
        return count_occurrences(lst[0], num) + count_occurrences(lst[1:], num)
    else:
        return 0 + count_occurrences(lst[1:], num)


Question 8: Sorting Tuples

Can we sort items other than integers? For this question, you will be sorting tuples!

We represent a person using a tuple (<gender>, <age>). Given a list of people, write a function sort_age that sorts the people and return a list in an order such that the older people are at the front of the list. An example of the list of people is [("M", 23), ("F", 19), ("M", 30)]. The sorted list would look like [("M", 30), ("M", 23), ("F", 19)].

You may assume that no two members in the list of people are of the same age.



Ans:

def sort_age(lst):
    for i in range(0,len(lst)-1):
        for j in range(i+1,len(lst)):
            if lst[i][1]<lst[j][1]:
                lst[i],lst[j]=lst[j],lst[i]
    return lst


Question 9: Not-so-simple Sorting

Sorting by age was simple. But the sorted result looks a little messy. Let's try to sort the list firstly by gender, and within each sorted section, sort by age in descending order. In this new sorted rule, the males should appear before the females. i.e. "M" < "F".

(Note that if we go by dictionary order, then "F" < "M". We deliberately flipped it for pragmatic reason. "Ladies first", we know ;) )


Ans:


def sort_by_gender_then_age(lst):
    for i in range(0, len(lst)-1):
        for j in range(i+1,len(lst)):
            if lst[i][0]<lst[j][0]:
                lst[i],lst[j]=lst[j],lst[i]
            elif lst[i][1]<lst[j][1]:
                lst[i],lst[j]=lst[j],lst[i]
            else:
                pass
    return lst
    

Question 10

Which of the following evaluates to the list [3, 6, 9, 12, 3, 6, 9, 12] ?

# a 
[3, 6, 9, 12] * 2
# b
([1, 2, 3, 4] * 3) * 2
# c
map(lambda x: x*3, [1, 2, 3, 4]*2)
# d
list(map(lambda x: x*3, (1, 2, 3, 4) * 2))
# e
[x * 3 for x in list(range(4))] * 2
# f
[i*3 for i in (3, 6) * 4]
# g
[3, 6, 9, 12, 3, 6, 9, 12, 3, 6, 9, 12, 3, 6, 9, 12] / 2 

Ans:

a, d

Question 11: Merge Sorted Lists

We introduced merge function in the lecture. Now write a similar function merge_lists that accepts two sorted lists descending order as inputs and merges them together to return a combined sorted list. Let's adopt the simple algorithm as follows:

1. Create a new empty list, that is to be used as the "merged list".
2. Look at the first left-most value of the two input lists. Select the larger value of the two, remove the value from the list it was in, and add it into the merged list. This will give you the largest out of the list (because it is sorted in descending order).
3. Repeat step 2 until both input lists are empty. If either one of the lists is empty during the process, then you can simply append the remaining non-empty list into the merged list.

Here is an example of the procedure above:

list1 = [5, 3]  list2 = [6, 4, 2]    merged_list = []
list1 = [5, 3]  list2 = [4, 2]       merged_list = [6]
list1 = [3]     list2 = [4, 2]       merged_list = [6, 5]
list1 = [3]     list2 = [2]          merged_list = [6, 5, 4]
list1 = []      list2 = [2]          merged_list = [6, 5, 4, 3]
list1 = []      list2 = []           merged_list = [6, 5, 4, 3, 2]

Ans:

def merge_lists(list1, list2):
    merged_list = []
    while len(list1) != 0 and len(list2) != 0:
        if list1[0] > list2[0]:
            merged_list.append(list1[0])
            list1.remove(list1[0])
            print(list1)
            print(list2)
        elif list1[0] < list2[0]:
            merged_list.append(list2[0])
            list2.remove(list2[0])
            print(list1)
            print(list2)
        elif list1[0] == list2[0]:
            merged_list.append(list1[0])
            list1.remove(list1[0])
            print(list1)
            print(list2)
        else:
            break
    if len(list2) == 0:
        merged_list.extend(list1)
    elif len(list1) == 0:
        merged_list.extend(list2)
    else:
        pass
    return merged_list

Question 12: Top K

Write a function top_k that accepts a list of integers as the input and returns the greatest k number of values as a list, with its elements sorted in descending order. You may use any sorting algorithm you wish, but you are not allowed to use sort and sorted.

Ans:

def top_k(lst, k):
    for i in range(len(lst)):
        for j in range(i + 1, len(lst)):
            if lst[i] < lst[j]:
               lst[i], lst[j] = lst[j], lst[i]
    k_top = lst[0:k]
    return k_top
   
 
Question 13

Which of these statements are true about the binary search algorithm?

Ans:

Time complexity is O(lgn).
It is faster than a linear search algorithm.
Binary search can be used on the following list [19,12,10,8,5,3,2] to search for an integer in sub-linear time.
