Question 1: Coin Change

Recall the coin change example that we had gone through during the lecture. Draw the tree illustrating the process generated by the cc(amount, d) function given in the lecture, in making change for 11 cents. (You don't need to submit the tree that you drew in Coursemology)

What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases? Specify your answer as strings.

Ans:

# Note: You don't need to submit your tree for coin change for 11 cents in Coursemology.
space_complexity = "O(a+n)"  # Enter the order of growth in space here
time_complexity = "Exponential in a"  # Enter the order of growth in time here

Question 2: Recursive function

A function f is defined by the rule that f(n) = n if n < 3 and f(n) = f(n - 1) + 2f(n  - 2) + 3f(n - 3) if n > 3.

Write a function f(n) that computes f by a recursive process

Ans:


def f(n):
    if n < 3:
       return n
    else:
        return f(n-1) + (2 * f(n-2)) + (3 * f(n-3))
    
# time_complexity="O(1)"
# space_complexity="O(n)"
# use ** to indicate power, without any spaces. For example, O(2**n)

Question 3: Iterative function

A function f is defined by the rule that f(n) = n if n < 3 and f(n) = f(n - 1) + 2f(n  - 2) + 3f(n - 3) if n > 3.

Write a function f(n) that computes f by a iterative process


def f(n):
    if n < 3:
        return n
    else:
        a, b, c = 0,1,2
        for i in range(3, n+1):
            a, b, c = b, c, (a * 3 + b * 2 + c)
        return c
        
Question 4: Test for fibonacci number

Write a function is_fib(n) that returns True if n is a Fibonacci number, and False otherwise.

Ans:

def checkPerfectSquare(n):
    sqrt = int(n**0.5)
    if sqrt ** 2 == n:
        return True
    else:
        return False
        
def is_fib(n):
    res1 = 5 * n * n + 4
    res2 = 5 * n * n - 4
    
    if n < 0:
        return False
    elif checkPerfectSquare(res1) or checkPerfectSquare(res2):
        return True
    else:
        return False

Question 5: Taxi Fare

Recall the taxi_fare example given in lecture 3? (Pasted below for your reference)

We would like to avoid the use of global variables, i.e. the variables deﬁned outside the function. In the lectures, we talked about variable scope within functions. We are allowed to deﬁne an inner function that makes use of a variable bound within an outer function. An example from the lectures is included in the PDF for this tutorial.

What if we were to return the inner function instead of just using it locally? The returned function would have access to the variables bound when it was returned. Deﬁne a function make_fare that takes as arguments stage1, stage2, start_fare,increment,block1 and block2 and returns a function that calculates the taxi fare using those values.

from math import *

stage1 = 1000
stage2 = 10000
start_fare = 3.0
increment = 0.22
block1 = 400
block2 = 350

def taxi_fare(distance):  # distance in metres
    if distance <= stage1:
        return start_fare
    elif distance <= stage2:
        return start_fare + (increment * ceil((distance - stage1) / block1))
    else:
        return taxi_fare(stage2) + (increment* ceil((distance - stage2) / block2))

Ans:

from math import *
def make_fare(stage1, stage2, start_fare, increment, block1, block2):
    def taxi_fare(distance, stage1, stage2, start_fare, increment, block1, block2):  # distance in metres
        if distance <= stage1:
            return start_fare
        elif distance <= stage2:
            return start_fare + (increment * ceil((distance - stage1) / block1))
        else:
            return taxi_fare(stage2) + (increment* ceil((distance - stage2) / block2))
    
    return lambda distance: taxi_fare(distance, stage1, stage2, start_fare, increment, block1, block2)
#DO NOT REMOVE THIS LINE
comfort_fare = make_fare(1000, 10000, 3.0, 0.22, 400, 350) 
